# Script-Orchestrator для перевода текстов

Этот проект автоматизирует перевод больших текстовых файлов (ранобэ) с японского на русский язык. Он использует `gemini-cli` для многоэтапной обработки текста. Система спроектирована с упором на отказоустойчивость, параллелизацию и высокое качество итогового текста.

### ВАЖНО
**Мне абсолютно не хотелось заморачиваться и писать воркеры на ноде, так что я _полностью навайбил_ (через Gemini 2.5 pro) скрипт на змее, поэтому какое качество кода, я без понятия. Заточен только под перевод данного тайтла.**

## Основные возможности

- **Интеллектуальное разделение глав**: Скрипт автоматически разбивает большие файлы на небольшие, семантически связанные части (`chunk_*.txt`).
- **Трехэтапный конвейер**:
  1.  **Поиск терминов (`discovery`)**: Параллельно обрабатывает все чанки для поиска новых терминов. Предлагает добавить их в основной глоссарий.
  2.  **Перевод со скользящим окном (`translation`)**: После подтверждения терминов переводит все чанки. Каждый чанк получает исходный текст предыдущего отрывка в качестве контекста. Это сохраняет связность повествования.
  3.  **Глобальная вычитка (`proofreading`)**: Проводит финальную обработку собранного текста. LLM генерирует JSON-патчи (diffs). Скрипт применяет их к тексту для исправления стилистических ошибок и соблюдения стайлгайда.
- **Параллельная обработка**: Запускает несколько процессов `gemini-cli` одновременно для ускорения работы.
- **Управление состоянием через SQLite**: Статусы чанков и глоссарий хранятся в локальной базе данных. Это обеспечивает надежность и транзакционность.
- **Интерактивный TUI**: Отображает прогресс выполнения и логи в реальном времени с помощью библиотеки `Rich`.
- **Отказоустойчивость**:
  - **Чекпоинты**: Сохранение статусов в БД позволяет пропускать уже выполненную работу при перезапуске.
  - **Возобновление (`--resume`)**: Безопасно продолжает прерванный процесс с места остановки.
  - **Автоматические повторы**: Встроенная система ретраев (через `tenacity`) обрабатывает временные ошибки API.

## Руководство пользователя

### 1. Предварительные требования

- Python 3.x
- Утилита `gemini-cli` (должна быть установлена и авторизована через `gemini auth`)

### 2. Установка

Клонируйте репозиторий и установите зависимости:

```bash
pip install -r requirements.txt
```

### 3. Структура файлов и директорий

- `text/chapters/<имя_главы>/jp.txt`: Исходный текстовый файл для перевода.
- `text/chapters/<имя_главы>/ru.txt`: Итоговый файл с финальным переводом.
- `translator.db`: База данных SQLite с состоянием чанков и глоссарием.
- `data/style_guide.md`: Правила стиля для перевода и вычитки.
- `prompts/`: Промпты для каждого этапа (`term_discovery.txt`, `translation.txt`, `proofreading.txt`).
- `config.json`: Главный файл конфигурации.
- `workspace/`: Временная рабочая директория для обработки файлов.

### 4. Конфигурация (`config.json`)

Основная настройка работы скрипта производится здесь.

- **`workspace_dir`**: Путь к корневой директории для временных файлов.
- **`max_concurrent_workers`**: Количество одновременно запущенных процессов `gemini-cli`. Рекомендуется значение 3 или 4 для соблюдения лимитов API (2 RPS).
- **`chapter_splitter`**: Настройки разделения текста.
  - `target_chunk_size`: Желаемый средний размер одного чанка в символах.
  - `max_part_chars`: Максимально допустимый размер чанка.
  - `min_chunk_size`: Минимальный размер чанка.
- **`gemini_cli`**:
  - `model`: Модель для использования (например, `"gemini-2.5-pro"` или `"gemini-3.0-pro-preview"`).

### 5. Как использовать

#### Стандартный запуск
Запускает полный трехэтапный процесс. После успешного завершения временная рабочая директория удаляется автоматически.

```bash
python main.py text/chapters/prologue/jp.txt
```

#### Запуск в режиме отладки (`--debug`)
Рекомендуемый режим для тестирования. Выполняет все то же самое, но сохраняет рабочую директорию после завершения. Позволяет изучить промежуточные результаты и логи.

```bash
python main.py --debug text/chapters/prologue/jp.txt
```

#### Принудительный чистый запуск (`--force-split`)
Полностью удаляет рабочую директорию и сбрасывает статус чанков в БД перед запуском. Используйте для старта с самого нуля.

```bash
python main.py --debug --force-split text/chapters/prologue/jp.txt
```

#### Возобновление после сбоя (`--resume`)
Позволяет продолжить прерванный процесс с этапа остановки. Пропускает уже завершенные чанки.

```bash
python main.py --debug --resume text/chapters/prologue/jp.txt
```

### 6. Рабочий процесс

1. Поместите исходный файл в `text/chapters/<имя_главы>/jp.txt`.
2. Запустите скрипт нужной командой.
3. Если скрипт найдет новые термины на этапе `discovery`, он остановится. Вам предложат подтвердить их через интерактивный интерфейс в терминале.
4. Следите за прогрессом перевода и вычитки через TUI.
5. Итоговый файл `ru.txt` появится рядом с исходным `jp.txt`.

## Руководство для разработчиков

### Архитектура

Система построена на принципе конвейера. Каждый из трех этапов (`discovery`, `translation`, `proofreading`) работает как независимый модуль. Состояние конвейера надежно хранится в SQLite.

- **Оркестратор (`orchestrator.py`)**: Управляет последовательностью выполнения конвейера. Вызывает воркеры для каждого этапа и проверяет статусы в БД.
- **База данных (`db.py`)**: Управляет SQLite-соединениями в режиме WAL. Хранит проекты, главы, чанки и глоссарий. Заменила старую файловую систему статусов.
- **Пользовательский интерфейс (`tui.py`)**: Отрисовывает прогресс-бары и интерактивные элементы с помощью библиотеки `Rich`.
- **Вычитка (`proofreader.py`)**: Реализует логику глобальной вычитки. Отправляет собранный текст в LLM и получает JSON-массив с исправлениями (diffs). Безопасно применяет их к тексту только при точном единичном совпадении.
- **Ограничитель запросов (`rate_limiter.py`)**: Потокобезопасный механизм для строгого соблюдения лимитов API (2 RPS).

### Жизненный цикл чанка

1. **Разделение**: `chapter_splitter.py` разбивает текст и сохраняет информацию о чанках в БД со статусом `pending`.
2. **Этап 1 (Discovery)**:
   - Воркер обрабатывает чанк.
   - Найденные термины сверяются с БД и предлагаются пользователю.
   - Статус чанка в БД меняется на `done`.
3. **Этап 2 (Translation)**:
   - Воркер переводит чанк. Он получает исходный текст предыдущего чанка для контекста.
   - Переведенный текст сохраняется, статус в БД обновляется.
4. **Сборка**: Оркестратор собирает черновой перевод из всех чанков.
5. **Этап 3 (Proofreading)**:
   - Собранный текст отправляется на вычитку.
   - Полученные JSON-патчи применяются к тексту.
6. **Финал**: Итоговый файл `ru.txt` сохраняется в директории главы.
