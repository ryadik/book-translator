# Book Translator (Script-Orchestrator)

Этот проект автоматизирует перевод больших текстовых файлов (ранобэ) с японского на русский язык. Он использует `gemini-cli` для многоэтапной обработки текста. Система спроектирована с упором на отказоустойчивость, параллелизацию и высокое качество итогового текста.

### ВАЖНО
**Мне абсолютно не хотелось заморачиваться и писать воркеры на ноде, так что я, почти полность, _навайбил_ скрипт на змее.**

## Основные возможности

* **Интеллектуальное разделение глав**: Скрипт автоматически разбивает большие файлы на небольшие, семантически связанные части (`chunk_*.txt`).
* **Трехэтапный конвейер**:
  1.  **Поиск терминов (`discovery`)**: Параллельно обрабатывает все чанки для поиска новых терминов. Предлагает добавить их в основной глоссарий.
  2.  **Перевод со скользящим окном (`translation`)**: После подтверждения терминов переводит все чанки. Каждый чанк получает исходный текст предыдущего отрывка в качестве контекста. Это сохраняет связность повествования.
  3.  **Глобальная вычитка (`proofreading`)**: Проводит финальную обработку собранного текста. LLM генерирует JSON-патчи (diffs). Скрипт применяет их к тексту для исправления стилистических ошибок и соблюдения стайлгайда.
* **Параллельная обработка**: Запускает несколько процессов `gemini-cli` одновременно для ускорения работы.
* **Управление состоянием через SQLite**: Статусы чанков и глоссарий хранятся в локальной базе данных. Это обеспечивает надежность и транзакционность.
* **Интерактивный TUI**: Отображает прогресс выполнения и логи в реальном времени с помощью библиотеки `Rich`.
* **Отказоустойчивость**:
  * **Чекпоинты**: Сохранение статусов в БД позволяет пропускать уже выполненную работу при перезапуске.
  * **Возобновление**: Безопасно продолжает прерванный процесс с места остановки.
  * **Автоматические повторы**: Встроенная система ретраев (через `tenacity`) обрабатывает временные ошибки API.

## Архитектура проекта (Серии и Тома)

Проект использует иерархическую структуру, ориентированную на перевод серий книг (ранобэ), состоящих из нескольких томов.

### Корневая директория серии (Series Root)
В корне серии хранятся общие настройки и глобальный глоссарий, применимый ко всем томам:
* `book-translator.toml`: Главный файл конфигурации серии. Заменяет старый `config.json`.
* `glossary.db`: Глобальная база данных SQLite с терминами для всей серии.
* `prompts/`: Директория с промптами для LLM.
* `style_guide.md`: Правила стиля для перевода.

### Директория тома (Volume Directory)
Каждый том серии находится в отдельной поддиректории и имеет собственную структуру:
* `source/`: Исходные текстовые файлы (например, `chapter1.txt`, `prologue.txt`).
* `output/`: Готовые переведенные файлы.
* `.state/`: Локальная база данных состояния (`state.db`) и временные файлы для конкретного тома.

## Руководство пользователя

### 1. Предварительные требования

* Python 3.x
* Утилита `gemini-cli` (должна быть установлена и авторизована через `gemini auth`)

### 2. Установка

Клонируйте репозиторий и установите зависимости:

```bash
pip install -r requirements.txt
```

### 3. Использование CLI

Управление проектом осуществляется через интерфейс командной строки (CLI). Основная команда: `book-translator`.

#### Инициализация серии (`init`)
Создает структуру директорий для новой серии и базовый конфигурационный файл `book-translator.toml`.

```bash
book-translator init "Название серии" --source-lang ja --target-lang ru
```

#### Перевод файла (`translate`)
Запускает процесс перевода для конкретного файла. Скрипт автоматически найдет конфигурацию серии в родительских директориях.

```bash
cd "Название серии"
book-translator translate volume-01/source/chapter1.txt
```
Дополнительные флаги:
* `--debug`: Включает подробное логирование.
* `--force-split`: Принудительно пересоздает чанки, удаляя старое состояние.
* `--resume`: Возобновляет прерванный перевод (поведение по умолчанию).

#### Управление глоссарием (`glossary`)
Позволяет просматривать, экспортировать и импортировать термины в глобальном глоссарии серии.

```bash
# Экспорт глоссария в TSV файл
book-translator glossary export --output terms.tsv

# Импорт глоссария из TSV файла
book-translator glossary import terms.tsv

# Просмотр всех терминов
book-translator glossary list
```

#### Статус перевода (`status`)
Отображает текущий прогресс перевода (количество обработанных чанков, текущий этап).

```bash
book-translator status
```
### 4. Конфигурация (`book-translator.toml`)

Основная настройка работы скрипта производится в файле `book-translator.toml` в корне серии.

* **`workers.max_concurrent`**: Количество одновременно запущенных процессов `gemini-cli`. Рекомендуется значение 3 или 4 для соблюдения лимитов API (2 RPS).
* **`chapter_splitter`**: Настройки разделения текста.
  * `target_chunk_size`: Желаемый средний размер одного чанка в символах.
  * `max_part_chars`: Максимально допустимый размер чанка.
  * `min_chunk_size`: Минимальный размер чанка.
* **`gemini_cli`**:
  * `model`: Модель для использования (например, `"gemini-2.5-pro"` или `"gemini-3.0-pro-preview"`).

### 5. Рабочий процесс

1. Инициализируйте новую серию: `book-translator init "my_book_series" --source-lang ja --target-lang ru`.
2. Перейдите в директорию серии: `cd "my_book_series"`.
3. Создайте директорию для тома и поместите исходные файлы: `mkdir -p volume-01/source/` и скопируйте туда `chapter1.txt`.
4. Запустите перевод: `book-translator translate volume-01/source/chapter1.txt`.
5. Если скрипт найдет новые термины на этапе `discovery`, он остановится. Вам предложат подтвердить их через интерактивный интерфейс в терминале.
6. Следите за прогрессом перевода и вычитки через TUI.
7. Итоговые файлы появятся в `volume-01/output/`.
## Руководство для разработчиков

### Структура проекта (`src` layout)

Проект использует стандартную для современных Python-приложений структуру `src` layout:

* `src/book_translator/` — весь исходный код приложения.
* `tests/` — модульные и интеграционные тесты (`pytest`).
* `pyproject.toml` — конфигурация сборки и зависимости.

### Архитектура конвейера

### Архитектура конвейера

Система построена на принципе конвейера. Каждый из трех этапов (`discovery`, `translation`, `proofreading`) работает как независимый модуль. Состояние конвейера надежно хранится в SQLite.

* **CLI (`cli.py`)**: Обрабатывает команды пользователя и запускает соответствующие модули.
* **Оркестратор (`orchestrator.py`)**: Управляет последовательностью выполнения конвейера. Вызывает воркеры для каждого этапа и проверяет статусы в БД.
* **База данных (`db.py`)**: Управляет SQLite-соединениями в режиме WAL. Разделена на глобальный глоссарий (`glossary.db`) и локальное состояние тома (`state.db`).
* **Пользовательский интерфейс (`tui.py`)**: Отрисовывает прогресс-бары и интерактивные элементы с помощью библиотеки `Rich`.
* **Вычитка (`proofreader.py`)**: Реализует логику глобальной вычитки. Отправляет собранный текст в LLM и получает JSON-массив с исправлениями (diffs). Безопасно применяет их к тексту только при точном единичном совпадении.
* **Ограничитель запросов (`rate_limiter.py`)**: Потокобезопасный механизм для строгого соблюдения лимитов API (2 RPS).

### Жизненный цикл файла

1. **Разделение**: `chapter_splitter.py` разбивает исходный текст из `source/` и сохраняет информацию о чанках в `state.db` со статусом `pending`.
2. **Этап 1 (Discovery)**:
   * Воркер обрабатывает чанк.
   * Найденные термины сверяются с `glossary.db` и предлагаются пользователю.
   * Статус чанка в `state.db` меняется на `done`.
3. **Этап 2 (Translation)**:
   * Воркер переводит чанк. Он получает исходный текст предыдущего чанка для контекста.
   * Переведенный текст сохраняется, статус в `state.db` обновляется.
4. **Сборка**: Оркестратор собирает черновой перевод из всех чанков.
5. **Этап 3 (Proofreading)**:
   * Собранный текст отправляется на вычитку.
   * Полученные JSON-патчи применяются к тексту.
6. **Финал**: Итоговый файл сохраняется в директории `output/`.


## Дистрибуция и Установка

Проект можно собрать и распространять как полноценную утилиту командной строки. Это позволяет запускать команду `book-translator` из любой директории без вызова `python main.py`.

### Сборка CLI-утилиты

Проще всего установить проект глобально через `pipx`. Эта утилита изолирует зависимости и добавляет исполняемый файл в ваш `PATH`.

```bash
pipx install .
```

Вы также можете использовать стандартный `pip`. Для этого в `setup.py` или `pyproject.toml` должны быть настроены `entry_points`.

```bash
pip install -e .
```
